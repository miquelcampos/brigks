# brigks
Brigks Modular Rig Builder for Autodesk Maya

**NOTICE**
This library is under MIT license

**CODING CONVENTION**
cmds vs pyMel vs API
Brigks is developed using Maya commands. 
You might find rare instance of pyMel or maya API in the code but the module should be using as much commands as possible. 
Maya commands are surprisingly the fastest way to execute python in Maya. pyMel might be more convinient to use, it is significanlty slower and should be avoided. Maya API in Python isn't really faster than commands and much more difficult to write. It's only used when there is no commands equivalent.

How to work around the lack of object pointer in Maya
When using commands, one issue you may encounter is the lack of persistent pointer to track an object. 
Commands returns and use the object name or path. The issue is that the object might be renamed or reparented which makes the stored invalid. 
Especially that Maya allows duplicate names for transforms as long as they don't share the same parent
Such a hierarchy is possible in Maya
|Setup
	|NodeA (1)
	|NodeB
		|NodeA (2)

First of all, Brigks assumes that any transform under the Setup or Guide node as a unique name. Anything built by Brigks has a unique name, and anything built manually by the user should still respect this convention. Try to keep your rig organized so you don't accidentally duplicate names.
Though, we can't guarantee that the name doesn't already exists somewhere in the scene so the approach in Brigks is to rely on object short path, which are in theory the safest. 
If we take the example above, we can't use the object name as there are two nodes named 'NodeA' and passing this to a command will throw a ValueError. 
We could use the long path (|Setup|NodeA and |Setup|NodeB|NodeA) but NodeB could be reparented during a connection and the path would become invalid.
So we are using the short path (|Setup|NodeA and |NodeB|NodeA), technically it can still fails if NodeA is reparented but we usually relies on buffer node (USE_BFR) to parent or connect things and we don't manipulate them as much other than for that reparenting. It is something to be mindful of though. 
One thing to consider, don't import another rig in the scene without usnig a namespace. If you need to import another rig and expect to run Brigks, this other rig needs to be in a namespace. It's likely that very similar hierarchy will exist in that other rig, which could confuse Brigks. Brigks might start altering the other rig (Delete nodes)

Object naming convention
If you start writing your own system, it is important than any node created respect the naming convention 
You can edit the naming convention in the config.py but you need to make sure the nodes generated by Brigks respect that naming. That includes transforms, shapes and utility nodes. Brigks rely on the respect of that naming convention to manipulate the systems. The system might build correctly the first time without a proper naming convention, but Brigks will not be able to find the nodes once built and will not be able to delete them if needed.

**ADDITIONAL MODULES AND PLUGINS**
Brigks currently relies on a few external modules and plugins

Python modules
- math3d: Python Math module developed by Tyler Fox at Blur Studio.

Maya Cpp Plugins
- harbieSolver: A set of custom solvers developed by Jeremie Passerin at Blur Studio
- harbieLocator: A custom locator and curve display developed by Guillaume Babin at Blur Studio
- harmonics: An Harmonic solver plugin developed by Tyler Fox at Blur Studio
- twistspline: A spline interpolation plugin developed by Tyler Fox at Blur Studio
https://github.com/blurstudio/TwistSpline

**BRIGKS API**
Brigks has been designed to be easily accessible thru a simple API. 
Anything you do thru the UI can very simply be done with the brigks API.
Example of the Brigks API can be found in examples.py